\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{dirtree}
\usepackage{listings}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\title{Técnicas de Búsqueda Ciega\\Sistemas Inteligentes}
\begin{document}
\maketitle
\pagebreak
\section{Torres de Hanoi}
\graphicspath{{/home/diego/Desktop/}}
\centering
\includegraphics[scale=0.48]{DeepinScreenshot_select-area_20180215153519.png}
\raggedright
\subsection{Reglas}
\index{reglas}
\begin{enumerate}
	\item Solo puedes mover el disco superior de cada columna.
	\item Solo puedes mover el disco superior de cada columna.
	\item Ningún disco puede estar encima de un disco más pequeño.
\end{enumerate}
\subsection{Objetivo}
Mover la torre entera a otra columna.
\subsection{Resolución}
\begin{enumerate}
	\item Se efectua el primer movimiento según el numero de anillos.
	\begin{itemize}
		\item Si n es impar, el primer movimiento será de A a C.
		\item Si n es par, el primer movimiento será de A a B.
	\end{itemize}
	\item Ningún anillo par se deberá poner directamente encima de otro anillo par.
	\item Ningún anillo impar se deberá poner directamente encima de otro anillo impar.
	\item Si hay más de un movimiento posible, (siendo las opciones una columna vacía y otra no está vacia) pon el disco en la columna que no esta vacía.
	\item Nunca muevas un disco el cual se ha movido en la rotación anterior.
	\item Repetir desde el paso 2 hasta completar.
\end{enumerate}
\pagebreak
\section{2n y 2n + 1}
\subsection{Enunciado}
Considere un espacio de estados donde el estado comienzo es el número 1 y la fun-
ción sucesor para el estado n devuelve 2 estados, los números 2n y 2n + 1.
\begin{enumerate}
	\item Dibuje el trozo del espacio de estados para los estados del 1 al 15.
	\item Supongamos que el estado objetivo es el 11. Enumere el orden en el que serán
	visitados los nodos por la búsqueda primero en anchura, búsqueda primero en
	profundidad con límite tres, y la búsqueda de profundidad iterativa.
	\item ¿Será apropiada la búsqueda bidireccional para este problema? Si es así, describa con detalle cómo trabajaría.
	\item ¿Qué es el factor de ramificación en cada dirección de la búsqueda bidireccional?
	\item ¿La respuesta (3) sugiere una nueva formulación del problema que permitiría
	resolver el problema de salir del estado 1 para conseguir un estado objetivo dado,
	con casi ninguna búsqueda?
\end{enumerate}
\subsection{Resolución}
\subsubsection{Dibuje el trozo del espacio de estados para los estados del 1 al 15.}
El arbol resultante sería el siguiente.\\
\dirtree{%
.1 1.
.2 2.
.3 4.
.4 8.
.5 14.
.5 15.
.4 9.
.3 5.
.4 10.
.4 11.
.2 3.
.3 6.
.4 12.
.4 13.
.3 7.
.4 14.
.4 15.
}
\pagebreak
\subsubsection{Supongamos que el estado objetivo es el 11. Enumere el orden en el que serán
visitados los nodos por la búsqueda primero en anchura, búsqueda primero en
profundidad con límite tres, y la búsqueda de profundidad iterativa.}
Por primero anchura, los nodos generados por el algoritmo de busqueda serian
\dirtree{%
.1 1.
.2 2.
.3 4.
.4 8.
.4 9.
.3 5.
.4 10.
.4 11.
.2 3.
.3 6.
.3 7.
}
El orden en el que accede sería:\\
\vspace{0.3cm}
1, 2, 3, 4, 5, 6, 7, 8, 9, 10 y 11\\
\vspace{1cm}
Y por primero profundidad con limite 3, los siguentes nodos serían explorados:
\dirtree{%
.1 1.
.2 2.
.3 4.
.4 8.
.4 9.
.3 5.
.4 10.
.4 11.
}
El orden en el que accede seria:\\
\vspace{0.3cm}
1, 2, 4, 8, 9, 5, 10 y 11\\
\vspace{1cm}
Finalmente por profundidad iterativa. En la cual se generarían los siguientes nodos:
\dirtree{%
.1 1 x4 (explorado 4 veces).
.2 2 x3.
.3 4 x2.
.4 8 x1.
.4 9 x1.
.3 5 x2.
.4 10 x1.
.4 11 x1.
}
El orden en el que accede seria el siguiente:\\
\vspace{0.3cm}
1,\hspace{0.3cm}1, 2,\hspace{0.3cm}1, 2, 4, 5,\hspace{0.3cm}1, 2, 4, 5, 8, 9, 10 y 11\\
\subsubsection{¿Será apropiada la búsqueda bidireccional para este problema? Si es así, descríba con detalle cómo trabajaría.}
Si partimos la busqueda en dos, tendremos dos busquedas $b^{d/2}$, lo cual resultaría en $b^{d/2}$ + $b^{d/2}$ que es consideráblemente menor que $b^{d}$
\begin{equation}
	b^{d/2} + b^{d/2} \ll b^{d}
\end{equation}
El problema es que esto no nos reduce el numero de nodos que tenemos que explorar, solo los reparte en dos busqedas, si fuera ordenación no sería así, pero al ser busqueda no mejora el orden
\subsubsection{¿Qué es el factor de ramificación en cada dirección de la búsqueda bidireccional?}
El factor de ramificación se refiere a cuantas busquedas se realizan por separado en el mismo arbol o red de nodos.
\subsubsection{¿La respuesta (3) sugiere una nueva formulación del problema que permitiría
resolver el problema de salir del estado 1 para conseguir un estado objetivo dado,
con casi ninguna búsqueda?}
No, por las mismas razones que se exponene en dicha respuesta



\section{Arbol}
\subsection{Enunciado}
Consideremos un árbol finito de profundidad d con un factor de ramificación b (un solo nodo raíz, con profundidad 0) y b sucesores por cada nodo, etc... Supongamos que el nodo objetivo menos profundo se encuentra a una profundidad g $\le$ d.
\begin{enumerate}
	\item ¿Cuál es el número mínimo de nodos generados por la búsqueda primero en profundidad con una profundidad límite d?. ¿Y el máximo?.
	\item ¿Cuál es el número mínimo de nodos generados por la búsqueda primero en anchura?.	¿Y el máximo?.
	\item ¿Cuál es el número mínimo de nodos generados por el descenso iterativo?. ¿Y el máximo?. (Considérese que comenzamos con una profundidad límite inicial de 1 y la vamos incrementando una unidad cada iteración).
\end{enumerate}
\subsection{Resolución}
\begin{enumerate}
	\item El numero de nodos mínimo generados por la función primero por profundidad será:
	\begin{equation}
		(d)
	\end{equation}
	ya que, si el nodo que estamos buscando esta contenido en la primera rama que buscamos, solo hará falta llegar hasta él de una forma lineal.\\
	Por otra parte, tenemos que el máximo será el numero totales de nodos menos la profundidad por debajo de d.
	\begin{equation}
		[n^b-(n-d)]
	\end{equation}
	Debido a que en el peor de los casos, pasaremos por todas las ramas erróneas y en la ultima, encontraremos el nodo deseado en el nivel de profundidad d.
	\item El numero mínimo de nodos generados utilizando primero en anchura será:
	\begin{equation}
		[(d-1^b)+1]
	\end{equation}
	ya que habrá que explorar todos los nodos de los niveles anteriores más el nodo buscado.\\
	En el caso contrario, el máximo sería que este sea el último nodo del nivel d, quedando el número de nodos generados por la búsqueda seria:
	\begin{equation}
		(d^b)
	\end{equation}
	\item El número mínino de nodos generados por descenso iterativo será:
	\begin{equation}
		(\sum_{i=0}^{(d-1)}b^i)+1
	\end{equation}
	siendo la totalidad de los niveles menores que d, (d-1) más el nodo buscado del nivel d.\\
	El máximo sería exactamente igual, pero sumándole todos los del nivel de profundidad d, quedando la siguiente expresión:
	\begin{equation}
		\sum_{i=0}^{d}b^i
	\end{equation}
	siendo el nodo buscado el último en ser accedido en el nivel d.
\end{enumerate}
\section{Sol y Sombra}
\index{reglas}
\begin{enumerate}
	\item Solo puedes mover un elemento a la vez.
	\item Los elementos pueden saltar, pero solo a otro elemento contiguo en su dirección de movimiento.
	\item Todos lo elementos solo se pueden mover hacia la dirección contraria del tablero, es decir, los de la derecha solo se pueden mover hacia la izquierda.
\end{enumerate}
\section{Objetivo}
\begin{itemize}
	\item Cambiar de posición ambos elementos (soles con sombras).
\end{itemize}
\section{Resolución}
El conjunto de pasos que da solución son dos, depende del primer movimiento.\\
Exploramos una de las ramas.\\
\centering
\begin{tabular}{ c  c  c  c  c  c  c }
	iteración & p1 & p2 & p3 & p4 & p5 & movimiento \\
	\hline
  iteración 0 & o & o &  & x & x & posición inicial \\
	iteración 1 & o & o & x &  & x & se mueve x \\
	iteración 2 & o &  & x & o & x & se mueve o \\
	iteración 3 &  & o & x & o & x & se mueve o \\
	iteración 4 & x & o &  & o & x & se mueve x \\
	iteración 5 & x & o & x & o &  & se mueve x \\
	iteración 6 & x & o & x &  & o & se mueve o \\
	iteración 7 & x &  & x & o & o & se mueve o \\
	iteración 8 & x & x &  & o & o & se mueve x, posición final \\
  \end{tabular}\\
\raggedright
\subsection{Algoritmo}
\subsubsection{Directivas}
\begin{enumerate}
	\item El primer movimiento es libre.
	\item Se mueven dos fichas (una antes y la otra después, en dos turnos) del símbolo contrario del símbolo de la ficha movida en el turno inicial, solo hay un movimiento legal por cada turno.\\
	\item Repetir paso dos hasta completar.
\end{enumerate}
Este algoritmo es valido n=[1,2] donde n $\in$ "numero de fichas de cada signo".
\subsubsection{Código del algoritmo}
Código que resuelve este problema (hecho en python):\\
\lstinputlisting[language=Python]{./sol_y_luna.py}
% \centering
% import sys
%
% class Tabletop:
% 	def __init__(self,_n_elem):
% 		self.table=[]
% 		self.iteration=0
% 		self.n_elem=int(_n_elem)
% 		#asignation of default values
% 		for i in range(0,(self.n_elem*2)+1):
% 			if i<self.n_elem:
% 				self.table.append(SHADOW)
% 			elif i==self.n_elem:
% 				self.table.append(EMPTY)
% 			else:
% 				self.table.append(SUN)
%
% 	def print_table(self):
% 		for i in range(0,(self.n_elem*2)+1):
% 			sys.stdout.write("____")
% 		sys.stdout.write("\n")
% 		sys.stdout.write("| ")
% 		for i in range(0,(self.n_elem*2)+1):
% 			sys.stdout.write(self.table[i])
% 			sys.stdout.write(" | ")
% 		print ("iteration no: %d"%self.iteration)
% 		for i in range(0,(self.n_elem*2)+1):
% 			sys.stdout.write("‾‾‾‾")
% 		sys.stdout.write("\n")
% 		return
%
% 	def move_sun(self):
% 		print("searching...")
% 		for i in range(1,(self.n_elem*2)+1):
% 			if self.table[i]==SUN and (self.table[i-1]==EMPTY or (self.table[i-2]==EMPTY and self.table[i-1]==SHADOW)):
% 				print("bingo!!")
% 				x=i
% 				if self.table[i-2]==EMPTY:
% 					y=i-2
% 				else:
% 					y=i-1
% 				#swap!
% 				aux=self.table[x]
% 				self.table[x]=self.table[y]
% 				self.table[y]=aux
% 				#end swap :(
% 				self.iteration+=1
% 				return True
% 		print("nope...")
% 		return False
%
% 	def move_shadow(self):
% 		print("searching...")
% 		for i in range(0,(self.n_elem*2)):
% 			if self.table[i]==SHADOW and (self.table[i+1]==EMPTY or (self.table[i+2]==EMPTY and self.table[i+1]==SUN)):
% 				print("bingo!!")
% 				x=i
% 				if self.table[i+2]==EMPTY:
% 					y=i+2
% 				else:
% 					y=i+1
% 				#swap!
% 				aux=self.table[x]
% 				self.table[x]=self.table[y]
% 				self.table[y]=aux
% 				#end swap :(
% 				self.iteration+=1
% 				return True
% 		print("nope...")
% 		return False
%
% 	def solve(self):
% 		if self.n_elem==1:
% 			self.move_sun()
% 			self.print_table()
% 			self.move_shadow()
% 			self.print_table()
% 			self.move_sun()
% 			self.print_table()
% 			print("\tfinished!")
% 			return
% 		else:
% 			self.print_table()
% 			solved=False
% 			if not self.move_shadow():
% 				return
% 			else:
% 				self.print_table()
% 				while not solved:
% 					try:
% 						self.move_sun()
% 					except:
% 						print("\tfinished!")
% 						return
% 					self.print_table()
%
% 					try:
% 						self.move_sun()
% 					except:
% 						print("\tfinished!")
% 						return
% 					self.print_table()
% 					try:
% 						self.move_shadow()
% 					except:
% 						print("\tfinished!")
% 						return
% 					self.print_table()
%
% 					try:
% 						self.move_shadow()
% 					except:
% 						print("\tfinished!")
% 						return
% 					self.print_table()
%
% 				return
%
% def main():
% 	#checks the argument
% 	if len(sys.argv)<2:
% 		print("the program needs a comand line argument for the number of elemnts")
% 		print("sol_y_luna.py <n_elem [1/2]>")
% 		return
%
% 	n_elem=str(sys.argv[1])
%
% 	if int(n_elem)<1 or int(n_elem)>2:
% 		print("\tinvalid number of elements! enter 1 or 2 elements\n")
% 		return
%
% 	greeting="\tThis program solves the sun and shadow game.\n \tThis is the initial tabletop"
% 	print(greeting)
%
% 	tabletop=Tabletop(n_elem)
% 	tabletop.solve()
% 	return
%
% if __name__ == "__main__":
% 	EMPTY= " "
% 	SHADOW = "x"
% 	SUN = "o"
% main()


\vspace*{\fill}
\raggedleft Documento escrito en \LaTeX{}
\end{document}
